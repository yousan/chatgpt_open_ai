{
  "id": "chatcmpl-7gDqr1772yMIeSDbRtBr1UX49eJBl",
  "object": "chat.completion",
  "created": 1690297377,
  "model": "gpt-3.5-turbo-0613",
  "choices": [
    {
      "index": 0,
      "message": {
        "role": "assistant",
        "content": "```typescript\n/**\n * メインの実行ファイル\n */\nclass Main {\n  /**\n   * ゲームの開始\n   */\n  start() {\n    // 1. ゲームの初期化\n    const board = this.initializeBoard();\n\n    // 6. 盤面の表示\n    this.displayBoard(board);\n\n    // 2. ゲームの進行\n    this.play(board);\n\n    // 7. ゲーム終了\n    this.end(board);\n  }\n\n  /**\n   * ゲームの進行\n   * @param {string[][]} board - 盤面の石の配置\n   */\n  play(board: string[][]) {\n    const player1 = 'B'; // 先手\n    const player2 = 'W'; // 後手\n    let currentPlayer = player1; // 現在のプレーヤー\n    let consecutivePasses = 0; // パスの回数\n\n    while (true) {\n      const validMoves = this.getValidMoves(board, currentPlayer);\n\n      if (validMoves.length === 0) {\n        // プレーヤーがパスの場合\n        consecutivePasses++;\n\n        if (consecutivePasses === 2) {\n          // プレーヤーが2回続けてパスした場合、ゲーム終了\n          break;\n        }\n\n        console.log(`${currentPlayer}のターン: パス`);\n      } else {\n        // プレーヤーが石を置く場合\n        consecutivePasses = 0;\n\n        console.log(`${currentPlayer}のターン`);\n        const [row, col] = this.getPlayerInput();\n\n        if (this.isValidMove(board, currentPlayer, row, col)) {\n          // 石を置く処理\n          this.placeStone(board, currentPlayer, row, col);\n\n          // 盤面の表示\n          this.displayBoard(board);\n\n          // プレーヤーの切り替え\n          currentPlayer = currentPlayer === player1 ? player2 : player1;\n        } else {\n          console.log('不正な座標が入力されました。再入力してください。');\n        }\n      }\n    }\n  }\n\n  /**\n   * ゲームの終了\n   * @param {string[][]} board - 盤面の石の配置\n   */\n  end(board: string[][]) {\n    // 盤面の石の数を数える\n    let blackCount = 0;\n    let whiteCount = 0;\n\n    for (let row = 0; row < 8; row++) {\n      for (let col = 0; col < 8; col++) {\n        if (board[row][col] === 'B') {\n          blackCount++;\n        } else if (board[row][col] === 'W') {\n          whiteCount++;\n        }\n      }\n    }\n\n    // 勝利プレーヤーの表示と結果の表示\n    if (blackCount > whiteCount) {\n      console.log('黒の勝利');\n      console.log(`黒: ${blackCount} 石, 白: ${whiteCount} 石`);\n    } else if (whiteCount > blackCount) {\n      console.log('白の勝利');\n      console.log(`黒: ${blackCount} 石, 白: ${whiteCount} 石`);\n    } else {\n      console.log('引き分け');\n      console.log(`黒: ${blackCount} 石, 白: ${whiteCount} 石`);\n    }\n  }\n\n  /**\n   * ゲームの初期化\n   * @returns {string[][]} - 初期化された盤面の石の配置\n   */\n  initializeBoard(): string[][] {\n    const board: string[][] = [];\n\n    for (let row = 0; row < 8; row++) {\n      board[row] = [];\n      for (let col = 0; col < 8; col++) {\n        board[row][col] = ' ';\n      }\n    }\n\n    board[3][3] = 'W';\n    board[3][4] = 'B';\n    board[4][3] = 'B';\n    board[4][4] = 'W';\n\n    return board;\n  }\n\n  /**\n   * 盤面の石の配置を表示する\n   * @param {string[][]} board - 盤面の石の配置\n   */\n  displayBoard(board: string[][]) {\n    for (let row = 0; row < 8; row++) {\n      let rowStr = '';\n      for (let col = 0; col < 8; col++) {\n        if (board[row][col] === 'B') {\n          rowStr += 'B ';\n        } else if (board[row][col] === 'W') {\n          rowStr += 'W ';\n        } else {\n          rowStr += '- ';\n        }\n      }\n      console.log(rowStr);\n    }\n  }\n\n  /**\n   * プレーヤーの入力を取得する\n   * @returns {number[]} - プレーヤーが入力した座標\n   */\n  getPlayerInput(): number[] {\n    const readlineSync = require('readline-sync');\n    const input = readlineSync.question('石を置く座標（行 列）を入力してください: ');\n    const [row, col] = input.split(' ').map((str) => parseInt(str));\n    return [row, col];\n  }\n\n  /**\n   * プレーヤーが置ける場所を取得する\n   * @param {string[][]} board - 盤面の石の配置\n   * @param {string} currentPlayer - 現在のプレーヤー\n   * @returns {number[][]} - プレーヤーが置ける場所の座標のリスト\n   */\n  getValidMoves(board: string[][], currentPlayer: string): number[][] {\n    const validMoves: number[][] = [];\n\n    for (let row = 0; row < 8; row++) {\n      for (let col = 0; col < 8; col++) {\n        if (this.isValidMove(board, currentPlayer, row, col)) {\n          validMoves.push([row, col]);\n        }\n      }\n    }\n\n    return validMoves;\n  }\n\n  /**\n   * 石を置くことができるかどうかを判定する\n   * @param {string[][]} board - 盤面の石の配置\n   * @param {string} currentPlayer - 現在のプレーヤー\n   * @param {number} row - 石を置く座標の行\n   * @param {number} col - 石を置く座標の列\n   * @returns {boolean} - 石を置くことができるかどうか\n   */\n  isValidMove(board: string[][], currentPlayer: string, row: number, col: number): boolean {\n    // 既に石が置かれている場所には石を置けない\n    if (board[row][col] !== ' ') {\n      return false;\n    }\n\n    // 8方向に対して挟むことができる石があるかどうかを判定する\n    for (let dRow = -1; dRow <= 1; dRow++) {\n      for (let dCol = -1; dCol <= 1; dCol++) {\n        if (dRow === 0 && dCol === 0) {\n          continue;\n        }\n        if (this.canFlip(board, currentPlayer, row, col, dRow, dCol)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * 石を置く処理\n   * @param {string[][]} board - 盤面の石の配置\n   * @param {string} currentPlayer - 現在のプレーヤー\n   * @param {number} row - 石を置く座標の行\n   * @param {number} col - 石を置く座標の列\n   */\n  placeStone(board: string[][], currentPlayer: string, row: number, col: number) {\n    board[row][col] = currentPlayer;\n\n    for (let dRow = -1; dRow <= 1; dRow++) {\n      for (let dCol = -1; dCol <= 1; dCol++) {\n        if (dRow === 0 && dCol === 0) {\n          continue;\n        }\n        if (this.canFlip(board, currentPlayer, row, col, dRow, dCol)) {\n          this.flipStones(board, currentPlayer, row, col, dRow, dCol);\n        }\n      }\n    }\n  }\n\n  /**\n   * 挟むことができる石があるかどうかを判定する\n   * @param {string[][]} board - 盤面の石の配置\n   * @param {string} currentPlayer - 現在のプレーヤー\n   * @param {number} row - 石を置く座標の行\n   * @param {number} col - 石を置く座標の列\n   * @param {number} dRow - 方向の行の増分\n   * @param {number} dCol - 方向の列の増分\n   * @returns {boolean} - 挟むことができる石があるかどうか\n   */\n  canFlip(board: string[][], currentPlayer: string, row: number, col: number, dRow: number, dCol: number): boolean {\n    const opponent = currentPlayer === 'B' ? 'W' : 'B';\n    let x = row + dRow;\n    let y = col + dCol;\n\n    if (!this.isValidPosition(x, y) || board[x][y] !== opponent) {\n      return false;\n    }\n\n    while (true) {\n      x += dRow;\n      y += dCol;\n\n      if (!this.isValidPosition(x, y)) {\n        return false;\n      }\n\n      if (board[x][y] === ' ') {\n        return false;\n      }\n\n      if (board[x][y] === currentPlayer) {\n        return true;\n      }\n    }\n  }\n\n  /**\n   * 石をひっくり返す\n   * @param {string[][]} board - 盤面の石の配置\n   * @param {string} currentPlayer - 現在のプレーヤー\n   * @param {number} row - 石を置く座標の行\n   * @param {number} col - 石を置く座標の列\n   * @param {number} dRow - 方向の行の増分\n   * @param {number} dCol - 方向の列の増分\n   */\n  flipStones(board: string[][], currentPlayer: string, row: number, col: number, dRow: number, dCol: number) {\n    const opponent = currentPlayer === 'B' ? 'W' : 'B';\n    let x = row + dRow;\n    let y = col + dCol;\n\n    while (board[x][y] === opponent) {\n      board[x][y] = currentPlayer;\n      x += dRow;\n      y += dCol;\n    }\n  }\n\n  /**\n   * 座標が正しい範囲内かどうかを判定する\n   * @param {number} row - 判定する座標の行\n   * @param {number} col - 判定する座標の列\n   * @returns {boolean} - 座標が正しい範囲内かどうか\n   */\n  isValidPosition(row: number, col: number): boolean {\n    return row >= 0 && row < 8 && col >= 0 && col < 8;\n  }\n}\n\n// ゲームの開始\nconst main = new Main();\nmain.start();\n```"
      },
      "finish_reason": "stop"
    }
  ],
  "usage": {
    "prompt_tokens": 1019,
    "completion_tokens": 2746,
    "total_tokens": 3765
  }
}
